# Интерпретатор Lenguage
Для запуска необходимо [сегнерировать](interpret/grammar_setup.md) дополнительные файлы для парсера по грамматике, затем исполнить:

```shell
python -m project "path_to_code.lll"
```

Весь вывод происходит в консоль. При неудачном исполнении код возврата будет возвращён.

## Загрузка графов и грамматик
Для загрузки графов и грамматик используются функции `load_graph` и `load_dot`, где первая загружает граф из удалённого датасета CFPQ_Data, а вторая если имя файла начинается с "cfg" загружает кс-грамматику из указанного файла, в ином случае - граф.

Все вершины графов считаются стартовыми и финальными, для кс-грамматик эти свойтсва нужно указывать с помощью `set_starting set_final add_starting add_final`.

## Используемые алгоритмы
Для нахождения достижимых вершин используется алгоритм построения транзитивного замыкания через возведение матриц смежности автоматов в степень, так как этот алгоритм уже был реализован.

Для пересечения конечных автоматов с рекурсивными используется внутренняя функция pyformlang.cfg `intersection`.

## Система типов
Используется строгая динамическая типизация, производящаяся во время испольнения путём проверки типов.

### Имена
С помощью оператора `:=` всякому имени может быть присвоено значение типа 't, тогда типом значения этого имени считается 't.

### Множеста 't Set
Типы данных, содержащие несколько значений одного типа 't.

Объекты этого типа создаются следующим образом:

- `<||>` - пустое множество, типом элементов будет `None`
- `<| e1, e2, ... |>` - множество из элементов `e1, e2, ...`
- `<| 1 .. 10 |>` - множество элементов типа INT, содержащие все значения от `1` до `10`

### Пары 't Pair
Типы данных, содержащие два упорядоченных значения одного типа 't.

Объекты этого типа создаются следующим образом:

- `(fst, cnd)` - пара с элементами `fst` и `snd`

### Тройки 't 'm Triple
Типы данных, содержащие три упорядоченных значения, где тип 't первого совпадает с типом 't последнего, тип второго - 'm.

Объекты этого типа создаются следующим образом:

- `(start, mark, final)` - пара с элементами `start`, `mark`, `final`

### Кс-грамматики 't 'm CFG
Тип данных, содержащий кс-грамматику, представленную как рекурсивный автомат, где значения вершин типа 't, а меток на рёбрах - 'm. Поддерживает операции изменения стартовых и финальных состояний, их добавление, получение, получение всех достижимых финальных состояний из стартовых, меток, вершин, сторон. Предусматривает пересечение с конечным автоматом, объединение и конкатенацию с другой грамматикой.

Объекты этого типа создаются следующим образом:

- `g"grammar"` - грамматика, где grammar - строковое представление грамматики [по правилам pyformlang](https://pyformlang.readthedocs.io/en/latest/usage.html#context-free-grammar).

### Конечные автоматы 't 'm Automa
Тип данных, содержащий кс-грамматику, представленную как рекурсивный автомат с вершинами типа 't и метками на рёбрах типа 'm. Поддерживает операции изменения стартовых и финальных состояний, их добавление, получение, получение всех достижимых финальных состояний из стартовых, меток, вершин, сторон. Предусматривает пересечение с кс-грамматикой, объединение и конкатенацию с другим автоматом.

Объекты этого типа создаются следующим образом:

- `r"regex"` - автомат, где regex - строковое представление регекса [по правилам pyformlang](https://pyformlang.readthedocs.io/en/latest/usage.html#regular-expression), по которому строится автомат.

### Прочие
Базовые типы, используемые интерпретатором:

- INT - целые числа
- STRING - строковые литералы, выделенные двойными кавычками
- BOOL - логические значения `true` и `false`

### Сопоставление с образцом 't Pattern
Лямбда функции используют следующие конструкции для динамического связывания их со значениями:

- `_` - выражение любого типа, которое "отбрасывается"
- `name` - имя с типом 't, с которым будет связано выражение
- `(fst, snd)` - раскрытие выражения как пары и сопоставление его частей с именами `fst` и `snd`
- `(starting, mark, final)` - аналог предыдущей конструкции, но для троек

Попытка сопоставления со значением неподхожящего типа приведёт к типовой ошибке.

## Функции

### Создание объектов:
- `<||>` -> `None Set`
- `<|INT .. INT|>` -> `INT Set`
- `<|'t, 't, .., 't|>` -> `'t Set`
- `('t, 't)` -> `'t Pair`
- `('t, 'm, 't)` -> `'t 'm Triple`
- `rSTRING` -> `STRING STRING Automa`
- `gSTRING` -> `STRING STRING CFG`
- `load_dot STRING` -> `'STRING STRING 'Automa` - если аргумент - имя файла, которое не начинается с "cfg"
- `load_dot STRING` -> `STRING STRING CFG` - если аргумент - имя файла, которое начинается с "cfg"
- `load_graph STRING` -> `STRING STRING Automa`

### Работа с множествами
- `'t in 't Set` -> `BOOL` - проверка на вхождение элемента в множество
- `'t Set map ('t Pattern => 'a)` -> `'a Set` - создание нового множества путём применения функции к элементам указанного множества
- `'t Set filter ('t Pattern => BOOL)` -> `'t Set` - создание нового множества, состоящего из тех элементов старого, что удовлетворяют указанной функции

### Изменение грамматик и автоматов
Добавление или установка стартовых или финальных вершин:
- `'t 'm Automa set_starting 't Set` -> `'t 'm Automa`
- `'t 'm Automa set_final 't Set` -> `'t 'm Automa`
- `'t 'm Automa add_starting 't Set` -> `'t 'm Automa`
- `'t 'm Automa add_final 't Set` -> `'t 'm Automa`
- `'t 'm CFG set_starting 't Set` -> `'t 'm CFG`
- `'t 'm CFG set_final 't Set` -> `'t 'm CFG`
- `'t 'm CFG add_starting 't Set` -> `'t 'm CFG`
- `'t 'm CFG add_final 't Set` -> `'t 'm CFG`

Получение стартовых, финальных, всех вершин, всех меток на рёбрах, всех рёбер как множество троек (вершина из, метка, вершина в):
- `'t 'm Automa starting` -> `'t Set`
- `'t 'm Automa final` -> `'t Set`
- `'t 'm Automa nodes` -> `'t Set`
- `'t 'm Automa marks` -> `'m Set`
- `'t 'm Automa edges` -> `'t 'm Triple Set`
- `'t 'm CFG starting` -> `'t Set`
- `'t 'm CFG final` -> `'t Set`
- `'t 'm CFG nodes` -> `'t Set`
- `'t 'm CFG nodes` -> `'m Set`
- `'t 'm CFG nodes` -> `'t 'm Triple Set`

Получение всех финальных достижимых из стартовых вершин как множество пар (стартовая, финальная):
- `'t 'm Automa reachables` -> `'t Pair Set`
- `'t 'm CFG reachables` -> `'t Pair Set`

Пересечение автоматов, где в результате вершины заново перенумерованы:
- `'t 'm Automa inters 't 'm Automa` -> `'t 'm Automa`
- `'t 'm CFG inters 't 'm CFG` -> `'t 'm CFG`
- `'t 'm CFG inters 't 'm Automa inters` -> `'t 'm CFG`
- `'t 'm Automa inters 't 'm CFG` -> `'t 'm CFG`

Объединение и конкатенация:
- `'t 'm Automa union 't 'm Automa` -> `'t 'm Automa`
- `'t 'm Automa concat 't 'm Automa` -> `'t 'm Automa`
- `'t 'm CFG union 't 'm CFG` -> `'t 'm CFG`
- `'t 'm CFG concat 't 'm CFG` -> `'t 'm CFG`

Звёздочка Клини:
- `'t 'm Automa star` -> `'t 'm Automa`
- `'t 'm CFG star` -> `'t 'm CFG`

### Инструкции
- `print` - вывод в консоль выражения любого типа
- `:=` - оператор связывания для выражений любого типа
